# 1주차



## 프로세스와 스레드



### 프로세스



#### 정의 

> *In computing, a process is the instance of a computer program that is being executed by one or many threads.*
>
> *컴퓨터 분야에서*  ***프로세스는 컴퓨터 프로그램의 인스턴스*** *로, 하나 이상의 스레드를 통해 실행된다.*

프로세스 : 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태를 말한다.운영체제로부터 주소 공간, 파일, 메모리 등을 할당 받으며 이것들을 총칭하여 `프로세스`라고 한다. `프로세스 스택`에는 함수의 `매개변수` `복귀주소`와 `로컬 변수`와 같은 임시자료를 가지고 있으며 이 `프로세스 스택`과 전역변수를 수록하는 `데이터 섹션`을 가지고 있다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 `힙`을 가지고 있다. 조금 어렵게 말하면 곧 실행 가능한 PCB를 가진 프로그램이라고 말 할 수 있다.



### 프로세스 제어 블록 (Process Control Block , PCB)



#### 정의

> 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳, 프로세스의 상태 정보를 저장하는 구조체이며, 프로세스 상태관리와 문맥교환을 위해 필요하다.

PCB는 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조임. 운영체제가 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다. 프로세스가 CPU를 항상 할당 받지 못하기 때문에 이 테이블이 필요하다, CPU를 할당받아 작업을 처리하다가 다른 프로세스에게 CPU를 넘겨야 하면 즉,전환이 발생하면 하던 작업을 저장하고 자원을 반환해야 하는데 이때 작업의 진행 상황을 모두 PCB에 저장하게 된다. 그리고 다음에 CPU를 할당받아 작업을 시작하게 된다면 PCB에 저장한 내용을 불러와 이전에 종료했던 시점부터 작업을 다시 수행한다.

#### 저장하는 정보

![image-20210226100633907](https://user-images.githubusercontent.com/42714724/109260155-fa72ce00-7840-11eb-91ec-6936bd83aabc.png)

[출처]:(https://jhnyang.tistory.com/33)

#### 

#### Context Switching 

현재 CPU를 사용하고 있는 프로세스의 정보는 CPU에 존재하고 있는 레지스터들이 저장하고 있음. 즉, CPU 내부 레지스터가 해당 정보를 저장하고 있기 때문에 별도의 저장공간을 필요로 하지 않는다. 이러다가 Interrupt가 걸리면 현재 수행하고 있던 것을 먼저 저장한다. Interrupt 가 되어 waiting 상태로 변하게 된 cpu는 다른 프로세스를 running 으로 바꿔 올리고 레지스터의 저장 값이 앞으로 수행할 프로세스에 관한 정보로 교체된다. 그렇기 때문에 이전에 작업하던 프로세스의 정보를 저장할 곳이 필요한데(나중에 running 이 되면 그 정보를 가지고 cpu를 사용해야하기 때문에) 현재 교체되기 전에 cpu 내부의 레지스터가 가지고 있던 정보를 pcb에 저장하는 것이다.  이러한 식으로 수행중인 프로세스를 변경할 때 레지스터에 프로세스의 정보가 바뀌는 것을 문맥교환이라고 한다.

#### 문맥교환의 Overhead 

프로세스가 일을 하다가 중간에 I/O 이벤트가 발생해서 기다려야 하는 상황이 발생하면 CPU를 놀리는게 되어버리고 이 상황에서 다른 프로세스를 running 시키지 않으면 cpu가 낭비된다고 볼 수 있다. 그렇기 때문에 cpu를 놀리는 상황을 만들바에는 그 시간에 다른 프로세스를 running 시키면서까지 (overhead) 를 감수하면서 문맥교환을 하는 것이 이득이라고 보면 된다.

## 

### 프로세스와 스레드의 차이



#### 정의 

> 프로세스 내에서 실행되는 실행 단위이다, 프로세스는 이러한 스레드 한개 이상으로 나눌 수 있다. 또한 스레드는 `실행 환경 정보`, `지역 데이터 스택`을 독립적으로 가지면서 `코드`,`전역 데이터 힙`을 다른 스레드와 공유한다.
>
> *In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system*
>
> *컴퓨터 분야에서 실행되는 스레드는 일반적으로 운영체제의 일부인 스케줄러에 의해 **독립적**으로 관리 될 수 있는 프로그래밍 된 명령어의 **가장 작은 시퀀스**다.*

일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다. 즉, 프로세스를 생성하면 기본적으로 하나의 메인 스레드가 생성되는 셈이다.



![image-20210226111235292](https://user-images.githubusercontent.com/42714724/109260158-fba3fb00-7840-11eb-9736-c6cf8ce68592.png)



프로세스는 실행될 때 운영체제로부터 각각 **독립된 메모리 영역을 할당 받는다**. 이에 반해 스레드는 한 프로세스 내에서 동작되는 흐름으로 프로세스 내에서 **Stack 영역만 별도로 할당 받고, 부모 프로세스의 Code Data Heap 영역은 공유한다.** 즉 프로세스 내에서 자식 스레드들은 서로 주소 공간이나 자원들을 공유하면서 실행될 수 있다.

### 멀티 프로세스와 멀티 스레드

#### 멀티 프로세스

> 멀티 프로세스란 하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.

![image-20210226111720597](https://user-images.githubusercontent.com/42714724/109260159-fba3fb00-7840-11eb-9ad1-5ec3c424d724.png)

#### 멀티 프로세스의 특징

- 여러개의 자식 프로세스 중 하나에 문제가 발생해도, 다른 자식 프로세스에 영향이 확산되지 않는다.
- 각 프로세스들이 독립적으로 동작하며 자원이 서로 다르게 할당된다.
- 메모리 사용량이 많다.
- 스케쥴링에 따른 문맥교환이 많아지고 성능 저하의 우려가 있다.

#### 멀티 스레드

> 하나의 애플리케이션을 여러 개의 스레드로 구성하여 하나의 스레드가 하나의 작업을 처리하도록 하는 것 이다.

사용자와 상호작용을 하는 애플리케이션에서 단일 스레드로 네트워크 또는 DB와 같은 긴 작업을 수행하는 경우 작업을 처리하는 동안 사용자와 상호작용이 불능인 상태가 될 수 있기 때문이다. 즉, 스레드가 생김으로서 상호작용이 불능인 상태일 때에도 각자 할일을 알아서 하기 위해서 존재한다고 볼 수 있다.

![image-20210226112144187](https://user-images.githubusercontent.com/42714724/109260160-fc3c9180-7840-11eb-8c17-6c53643a5cab.png)



#### 멀티 스레드의 특징 

- 프로그램의 일부분 즉, 자식스레드가 긴 오류 또는 긴 작업으로 인해 중단되어도 프로그램이 계속 지속적으로 수행된다.
- 자원 공유가 쉽다. 스레드들은 부모 프로세스의 자원과 메모리 공유를 할 수 있다.
- 프로세스를 할당하는 것보다 스레드를 할당하는 것이 비용이 적게 든다.
- 멀티 프로세서 구조에서 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다.
- 구현 및 테스트,디버깅이 어렵다.
- 너무 많은 스레드 사용은 오버헤드를 발생시킨다.
- 동기화 , 교착상태가 발생하지 않도록 주의해야 한다.
- 자식 스레드 중 하나에 문제가 생긴 경우 전체 프로세스에 영향을 줄 수 있다. 

#### 멀티 프로세스 VS 멀티 스레드

멀티 스레드는 멀티 프로세스에 비해 상당한 이점을 가지지만 이에 반해 가지는 위험부담도 크다.

- 문맥교환시에 공유 메모리 만큼의 시간 손실이 줄어든다 : 프로세스 간의 컨텍스트 스위칭시 단순히 cpu 레지스터 교체 뿐만이 아니라 RAM과 CPU사이의 캐쉬 메모리에 대한 데이터까지 초기화 되므로 상당한 부담이 발생하기 때문이다.

- Stack을 제외한 모든 메모리를 공유하기 때문에 global , static 그리고 new maloc 에 의한 모든 자료를 공유 할 수 있다 : 프로세스간의 통신을 거치지 않고 일처리가 가능하다, 더불어 핸들테이블과 환경변수도 가능하다.

- 여러개의 스레드가 동일한 데이터 공간을 공유하며 수정한다는 점에서 필연적인 문제가 발생한다 : 프로세스의 경우 자신의 데이터 공간을 망가뜨리면 망가진  프로세스만 중단되지만 스레드의 경우 해당 스레드와 공간을 공유하는 모든 스레드를 작동 불능 상태로 만들어버린다. 이런 문제에 대한 해법으로 Critical Section 기법이 존재한다.

  

## 스케줄러



#### 정의

> 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행 할 수 있는 프로세스 중에 하나를 선택하는 역할을 하는 운영체제 커널의 모듈



### 장기 스케줄러



#### 역할

> ***어떤 프로세스를 준비 큐에 넣을 것 인가?***

작업 스케줄러 라고도 부르며 어떤 프로세스를 준비큐에 삽입할지를 결정하는 역할을 합니다. 디스크에서 하나의 프로그램에 가져와 커널에 등록하면 프로세스가 되는데 이때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지 결정합니다.



### 단기 스케줄러



#### 역할

> ***어떤 프로세스에게 CPU를 할당해 줄 것인가?***

CPU 스케줄러라고도 불리며 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것 인지를 결정함. 시분할 시스템에서 타이머 인터럽트가 발생하면 `단기 스케줄`러가 호출된다. 일반적인 스케줄러라 지칭하는 것의 대부분은 `단기 스케줄러`를 의미하며 단기 스케줄러를 미리 정한 `스케줄링 알고리즘`에 따라 CPU 할당 프로세스를 선택함.



### 중기 스케줄러



#### 역할 

> ***메모리에 적재된 프로세스의 수는 적당한가?***

너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가 된 스케줄러이다.너무 많은 수의 프로세스가 적재되어 `프로세스 당 보유 메모리량`이 적어지게 되면 CPU 수행에 필요한 프로세스의 주소 공간조차도 메모리에 올려놓기 어려운 상황이 발생한다. 이러한 상황이 발생하게 되면 디스크 I/O가 수시로 발생하게 되어 시스템의 성능이 심각하게 저하 될 수 있기 때문에 메모리에 올라와 있는 프로세스 중 일부로 부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장해 두는데 이러한 동작을 `스왑아웃`이라 부른다.

#### 스왑아웃

1. 봉쇄상태에 있는 프로세스 : 해당 상태에 놓인 프로세스들은 당장 CPU를 획득할 가능성이 없기 때문이다.
2. 인터럽트가 발생해 준비큐로 이동하는 프로세스 

중기 스케줄러의 등장으로 프로세스의 상태에는 `중지상태`가 추가 되었으며,중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃 된다.

중지상태에는 `중지 준비 상태`와 `봉쇄 중지 상태`가 있다.

`중지 봉쇄 상태` -> 조건 만족 -> `중지 준비 상태`

중지 상태에 있는 프로세스들은 `중지 준비 상태`이든 `중지 봉쇄 상태`이든 관계없이 메모리를 조금도 보유하지 않고 디스크에 통째로 `스왑아웃`된 상태로 존재하게 된다.


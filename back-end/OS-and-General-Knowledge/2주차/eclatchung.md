# CPU 스케줄링

- 스케줄링 역할
	1. 여러 프로세스가 CPU를 점유 시 누구에게 줄것인지 선택
	2. 한 프로세스가 CPU를 점유할 시 얼마만큼 오래 CPU 부여를 할것인지 선택
- 스케줄링 알고리즘
	어떤 프로세스 종료 후 다음 프로세스 선택하는 알고리즘


- 어떤 user program 이 수행 중일 때, blocking  sys call을 할 시 I/O wait 상태로 천이함. 
	- `CPU burst` : 프로그램의 수행 중에 연속적으로 CPU를 사용하는 단절된 구간 - 스케줄링의 단위가 됨
	- `I/O burst` : 프로그램 수행중에 I/O 작업이 끝날때까지 block되는 구간. 
	

- 종류 ( 결정 모드 )
	1. `선점` (Preemptive)
		- CPU 강제 점유 가능
	2. `비선점`Non- Preemptive)
		- 입출력 인터럽트 발생 또는 프로세스 종료 까지 기다림. 

- CPU 스케쥴링이 필요한 경우
	1. Ready -> Running : Dispatcher가 담당
	2. Running -> Blocked (ex: I/O 요청하는 시스템 콜) : 자진 반납(nonpreemptive)
	3. Running -> Waiting : (Non-Preemptive / SW Interrupt)
	4. Terminate : 자진 반납(nonpreemptive)
	5. Blocked -> Ready (ex: I/O완료 후 interrupt) : 강제 반납(preemptive)
	6. Running -> Ready (ex: 할당시간만료로 timer interrupt) : 강제 반납(preemptive / HW interrupt)


- 스케줄링 척도( scheduling criteria)
	+ 사용자 중심의 성능 관련 척도
		1. `반환 시간` :  프로세스가 시스템으로 진입한 후 부터 종료할때까지 걸린 시간
		2. `응답 시간` : 프로세스가 시스템에 요구를 한 후 이에 대한 시스템으로부터 첫 번째 응답이 올때까지의 시간.
		3. `완료기한` : 프로세스가 완료 되어야 하는 시점
	- 사용자 중심의 기타 평가 척도
		1. `예측 가능성` : 같은 작업이라면 실행 될때 마다 동일한 기간 동안 실행되어야 하고, 시스템 부하 정도에 상관없이 동일한 비용으로 실행되어야 한다. ⇒ 시스템의 신뢰감을 위하여
	- 시스템 중심의 성능 관련 평가 척도
		1. `처리량` : 단위 시간 내에 실행을 완료 시킬 수가 있는 프로세스
		2. `처리 이용률` : 전체 시간 중에 처리기가 바쁘게 실행을 한 시간의 비율
	- 시스템 중심의 기타 평가 척도
		1. `공정성`
		2. `우선순위 부여`
		3. `균형있는 자원 활용`
- 스케줄링의 정책
	1. CPU 이용률을 최대화
	2. 오버헤드의 최소화
	3. 모든 Process에게 공평


## 알고리즘 
### `FCFS`(First Come First Served)
- Queue(FIFO) 와 동일
- 프로세스 처리 순서에 따라 성능 크게 달라진다. 
- 콘보이효과(Convoy effect) : 수행 시간이 큰 프로세스가 먼저 들어올시  그 뒤에 돌아온 프로세스들이 불필요하게 오랜 시간 기다림.
- 비선점 스케줄링
### `SJF`(Shortest Job First)
- 프로세스 수행 시간이 짧은 순서에 따라 프로세서 할당
- FCFS의 콘보이 효과 해결
- 최적 알고리즘이 수행시간 정확히 알수 없다. 
- burst 시간 큰 프로세스는 계속 밀려가는 기아 (starvation)발생
- 비선점 스케줄링
### `SRTF`(Shortest Remaining Time First)
- 프로세스의 남은 수행시간이 짧은 순서에 따라 프로세스 할당
- SJF의 기아 문제 해결
- 프로세스가 언제 작업을 마치는지를 알 수 없음
- 수행중 다른 프로세스보다 남은 수행이 적어지면 OS 개입
- 선점 스케줄링
### `우선순위 스케줄링`
- 우선순위가 높은 프로세스 먼저 처리하는 스케줄링 기법
- 작은 숫자가 우선순위가 높다
- 기아현상이 발생할 수 있다.
- 기아현상 해결책 ⇒ aging : 오래된 프로세스의 우선순위를 높여주는 방법
### `RR`(Round Robinx)
- 일반적으로 쓰이는 스케줄링 기법으로 각 프로세스는 동일한 크기와 할당 시간을 가짐
- 응답시간이 빠르다
- 할당시간을 지나치게 크게하면 FCFS와 동일하게 동작됨
- 할당시간을 지나치게 작게하면 잦은 문맥전환(Context switch)로 인해 오버헤드가 높아져서 성능이 저하된다.
- 할당 시간으로 일반적을 10 ~ 100ms


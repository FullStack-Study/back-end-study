## 스케줄링 



> *CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야한다, 이때 다음 프로세스가 어느 프로세스인지를 선택하는 알고리즘을 CPU Scheduling 알고리즘이라 한다.*



## 선점과 비선점



### 1. 선점

선점은 프로세스가 cpu를 점유하고 있는 동안 I/O 혹은 인터럽트가 발생한것도 아니고 모든 작업을 끝내지고 않았지만 다른 프로세스가 해당 CPU를 강제롤 점유 할 수 있다. 즉, 프로세스가 정상적으로 수행중인 가운데 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있는 것이다.

### 2.비선점

한 프로세스가 한번 CPU를 점유했다면 I/O나 인터럽트 발생 또는 프로세스 종료가 될 때 까지 다른 프로세스가 CPU를 점유하지 못하는 것임.



## 알고리즘



### First - Come , First-Served  (비선점)

먼저 온 프로세스가 먼저 CPU를 점유하는 방식

**Convoy Effect** : CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그 만큼 오래 기다리는 것

즉, 하나의 프로세스가 끝나기 전에는 다른 프로세스가 중간에 끼어들 수가 없음.



### Shortest-Job-First

가장 짧게 수행되는 프로세스가 가장 먼저 수행된다. 평균 대기시간이 짧다.

그러나 현실적인 컴퓨터 환경에서는 프로세스의 CPU 점유 시간을 알 수 없기 때문,,실제 측정한 시간으로 예측해서 사용할 수 있지만 오버헤드가 매우 크기때문에 사용되지는 않음..

선점,비선점 둘다 사용 가능함.



#### Priority

우선순위가 높은 프로세스가 먼저 선택되는 알고리즘이다.

**기아문제** : CPU의 점유를 오랫동안 하지 못하는 현상이 있다. 우선순위가 매우 낮은 프로세스가 대기하고 있다고 가정하면 이 프로세스는 아무리 오래 기다려도 CPU를 점유하지 못할 가능성이 매우 높음.. 즉, 우선순위가 낮은 프로세스들은 하염없이 기다리고만 있는 상태로 남아있을 수 있다.이러한 문제는 aging으로 해결 가능한데, 레디큐에서 기다리는 동안 일정 시간이 지나면 우선순위를 높여주어 수행가능성이 커짐..



### Round -Robin

원 모양으로 모든 프로세스가 돌아가며 스케줄링하는 것을 말함. 주로 시분할 시스템에서 주로 사용하는 방식이다. 일정시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아감. 일정시간(**Time quantum**)을 정하여 하나의 프로세스가 해당 시간동안 수행하고 다시 대기 상태로 돌아간다. 이 알고리즘은 기본적으로 선점형식이다. 한 프로세스가 종료되기 전에 일정시간이 끝나면 다른 프로세스로 CPU를 넘겨주기 때문에 이 해당시곤에 매우 의존적이다..
# 가상 메모리



## 정의

> *물리 메모리 크키긔 한계를 극복하기 위해 나온 기술이다. 즉 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다.*



## 개요

메인메모리의 크기는 한정되어 있기 때문에 물리적인 메모리 크기보다 크기가 큰 프로세스는 실행시킬 수 없다.그렇다면 메인 메모리보다 크기가 큰 프로세스를 실행시키고 싶으면 어떻게 해야 할까? 메인메모리가 더 큰 컴퓨터를 사용해야하는가? 이러한 고민에서 나온 해결방법이 가상메모리이다.

프로세스의 모든 코드는 항상 필요한것이 아니다.오류처리,필요없는 배열의 부분은 프로세스가 잘 동작하면 필요없는 부분이 된다.이러한 점을 이용하여 필요한 부분만 메모리에 올림으로서 메모리에 올라가는 프로세스의 크기를 줄인다.

일단, 우리는 우리가 실행시키고자 하는 프로세스들을 페이징 한 후 페이지 단위로 프로세스를 자르면 페이지들마다 필요한 부분과 필요없는 부분으로 나눌 수 있다. 여기서 필요한 페이지만 메모리에 적재를 하면 낭비없이 우리가 필요한 모든 프로세스들을 메인 메모리에서 실행 시킬 수 있게 된다.

여기에서 핵심은 **필요한 부분만 메모리에 적재한다** 이다 . 프로세스를 실행할 때 실행에 필요한 부분만 메모리에 올리는데 이러한 일부분은 페이지 단위일 수도 있고 세그먼트 단위일 수도 있다.(대부분은 페이지 단위이다) 이처럼 현재 필요한 페이지만 메모리에 올리는 것을 `요구 페이징` 이라고 한다.



## Demanding Paging

`요구 페이징` 은 프로세스의 이미지를 페이지를 임시로 보관하는 공간인 backing store에 프로세스의 이미지를 저장한다.프로세스는 페이지의 조합이기 때문에 필요한 페이지만 메모리에 올린다.요구되는 페이지만 메모리에 올린다는 의미로 요구페이징이라고 부른다.

페이징 기법을 사용할 때 페이지 테이블이라는 부분을 놔두는데 MMU의 재배치 레지스터를 통해 논리주소를 물리주소로 바꾸어주는 주소 변환 과정을 거쳐  CPU가 프로세스는 연속적으로 할당되어 있다고 속게 만드는 작업을 한다. 더불어 요구 페이징 기법을 사용하면 페이지 중 메모리에 올라와있는 것도 있고 backing store에 보관되어 있는것도 존재한다. 이렇게 섞여 있기 때문에 페이지 테이블을 작성할 때 이를 구분해줄 도구가 필요한데 그것이 바로 `valid 비트 필드` 를 페이지 테이블을 추가해서 구분한다.

만약, backing store 에 있는, 즉 현재 메모리에 올라와있지 않은 것인지 아닌지를 구분할때 `valid 비트 필드` 를 통해 알 수 있다.  `valid 비트 필드` 를 통해 해당 페이지의 부재를 확인하고 메모리에 적재한 후에는 `valid 비트 필드` 를 메모리에 적재되어있다고 바꾸어 주면 되고 이러한 현상을 `페이지 결함` `페이지 부재`라고 한다.

요구 페이징의 기법에는 두가지 종류가 있는데 첫번째는 모든 페이지를 적재시키지 않고 CPU가 요구할때 `valid`를 바꾸어 페이지를 적재하는 방법이며, 두번째는 우선 필요할 것 같은 페이지를 적재시키고 필요할 때 다른 페이지를 적재시키는 방법이다. 

첫번째는 ` pure demand paging` 두번째는 `prepaging`기법이다.  첫번째의 경우 메모리 낭비를 줄일 수 있지만 요구에 의해 앞선 페이지 부재의 현상을 처리하는데에 있어서 부담이 발생할 수 있다 두번째의 경우 처리속도는 빠르지만 메모리가 낭비 될 수 있다.



## 페이지 교체 알고리즘



1. 디스크에서 필요한 페이지를 위치를 알아낸다
2. 빈 페이지 프레임을 찾는다
3. 새롭게 비워진 프레임에 새 페이지를 읽어오고 프레임 테이블을 수정한다
4. 사용자 프로세스를 재시작한다.

### FIFO 페이지 교체

메모리에 올라온 기간이 가장 오래된 페이지를 내쫒는다.

단점 : Belady 의 모순이 발생한다. 프로세스에게 프레임을 더 주었는데도 페이지 부재율이 더 증가하는 현상.

### 최적 페이지 교체  

모든 알고리즘보다 낮은 페이지 부재율을 보이며 Belady 의 모순이 발생하지 않는다.

단점 : 프로세스가 앞으로 메모리를 어떻게 참조할 것인지를 미리 알아야하기 때문에 구현이 어렵다.

### LRU 페이지 교체

최근의 과거를 가까운 미래의 근사치르 본다면 가장 오랜 기간 동안 사용되지 않은 페이지를 교체한다. Belady의 모순 형상을 야기하지 않으며 가장 오랫동안  사용하지 않은 페이지를 교체하며 가장 가까운 미래의 근사값으로 가장 최근의 과거를 사용한다.최적 알고리즘과의 대칭성 떄문에 성능이 유사하다.

구현방법은 두가지로 각 페이지 항목마다 사용시간 필드를 넣고  CPU에 논리적인 시계나 계수기를 추가하여 페이지에 대한 참조가 일어날 때 마다 페이지의 사용시간 필드에 시간 레지스터의 내용이 복사되는 방법과 페이지 번호의 스택을 유지하는 방법이 있다. 

#### LRU 근사 페이지 교체 

참조 비트를 이용한 알고리즘으로 각 페이지에 대한 N Bit를 참조용으로 유지하는 것이다.

#### LFU 

사용빈도가 가장 적은 페이지를 교체하는 방법. 활발하게 사용되는 페이지는 교체죄디 않는다. 프로그램 실행 초기에 많이 사용된 페이지가 그 후로 사용되지 않을 경우에도 프레임을 계속 차지하느 ㄴ경우가 있을 수 있다.

#### 2차 기회 알고리즘

참조비트가 0이면 페이지를 교체하고 1이면 다시 한번 기회를 주고 다음 FIFO 페이지를 선택하기 위해 이동하는 알고리즘 




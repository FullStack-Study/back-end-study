# 가상 메모리

*프로그램을 실행하는데 필요한 최소한의 메모리는 얼마인가?*


## 정의

> *물리 메모리 크키긔 한계를 극복하기 위해 나온 기술이다. 즉 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다.*



## 개요


메인메모리의 크기는 한정되어 있기 때문에 물리적인 메모리 크기보다 크기가 큰 프로세스는 실행시킬 수 없다.그렇다면 메인 메모리보다 크기가 큰 프로세스를 실행시키고 싶으면 어떻게 해야 할까? 메인메모리가 더 큰 컴퓨터를 사용해야하는가? 이러한 고민에서 나온 해결방법이 가상메모리이다.

프로세스의 모든 코드는 항상 필요한것이 아니다.오류처리,필요없는 배열의 부분은 프로세스가 잘 동작하면 필요없는 부분이 된다.이러한 점을 이용하여 필요한 부분만 메모리에 올림으로서 메모리에 올라가는 프로세스의 크기를 줄인다.

일단, 우리는 우리가 실행시키고자 하는 프로세스들을 페이징 한 후 페이지 단위로 프로세스를 자르면 페이지들마다 필요한 부분과 필요없는 부분으로 나눌 수 있다. 여기서 필요한 페이지만 메모리에 적재를 하면 낭비없이 우리가 필요한 모든 프로세스들을 메인 메모리에서 실행 시킬 수 있게 된다.

여기에서 핵심은 **필요한 부분만 메모리에 적재한다** 이다 . 프로세스를 실행할 때 실행에 필요한 부분만 메모리에 올리는데 이러한 일부분은 페이지 단위일 수도 있고 세그먼트 단위일 수도 있다.(대부분은 페이지 단위이다) 이처럼 현재 필요한 페이지만 메모리에 올리는 것을 `요구 페이징` 이라고 한다.

### **추가설명**

운영체제는 가동되고 있는 프로세스들의 내용(페이지) 중, 덜 중요한 것들을 하드 디스크의 공간에 옮겨 놓는다. (당연히 어디에 저장했는지도 기록해 놓는다.) 그리고 프로세스가 동작하는 도중, 메모리에 필요한 데이터(페이지)가 없으면 하드디스크를 찾아 해당 데이터를 가져온다. (이 과정에서 속도 저하가 발생. ROM이 RAM보다 느리기 때문.)

if 가상 메모리의 내용을 물리 메모리에 로드하는 과정을 생각해본다면, 로드할 때 무작위로 위치 및 크기를 설정하여 로드하면 메모리 공간에 빈공간이 발생한다. 이를 최소화 하기 위해 아래의 두 요소를 도입한 것 이다.

`프레임(Frame)`: 물리 메모리를 사용하는 최소 크기 단위.

`페이지(Page)`: 가상 메모리를 사용하는 최소 크기 단위로 프로세스의 구성요소이다.

## page fault

### 사전지식

`swapping` : 프로세스는 실행되려면 반드시 메모리에 올라가야한다. 그런데 프로세스는 메모리에서 잠깐 뒤 저장공간(하드웨어 or SSD) 로 빠졌다가 다시 메모리에 돌아왔다를 반복합니다.이런식으로 교체되는 것을 스와핑이라 합니다.

`Lazy swapper` : 프로세스를 읽어 들일 때(swap in), 전체 프로세스가 아닌 필요한 page만 적재하도록 해준다.

### 정의 

> 운영체제의 스와퍼는 물리 메모리에 동작하고 있는 모든 프로세스를 로드하지 않는다. 또한 운영체제의 페이저는 프로세스의 모든 페이지를 물리메모리에 도르하지 않는다(물리 메모리를 효율적으로 사용하기 위함) 그러므로 프로그램의 페이지가 물리 메모리에 부재할 수 있는데 이것을 페이지 폴트라고 한다.

> 페이지 폴트란 프로그램이 자신의 주소 공간(가상메모리공간)에는 존재하지만 시스템의 RAM에는 현재 없는 데이터나 코드에 접근 시도하였을 경우 발생하는 현상을 말한다.

페이지 폴트가 발생하면 운영체제는 그 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 것 처럼 프로그램이 계속적으로 동작하게 해준다! 


## Demanding Paging

`요구 페이징` 은 프로세스의 이미지를 페이지를 임시로 보관하는 공간인 backing store에 프로세스의 이미지를 저장한다.프로세스는 페이지의 조합이기 때문에 필요한 페이지만 메모리에 올린다.요구되는 페이지만 메모리에 올린다는 의미로 요구페이징이라고 부른다.

페이징 기법을 사용할 때 페이지 테이블이라는 부분을 놔두는데 MMU의 재배치 레지스터를 통해 논리주소를 물리주소로 바꾸어주는 주소 변환 과정을 거쳐  CPU가 프로세스는 연속적으로 할당되어 있다고 속게 만드는 작업을 한다. 더불어 요구 페이징 기법을 사용하면 페이지 중 메모리에 올라와있는 것도 있고 backing store에 보관되어 있는것도 존재한다. 이렇게 섞여 있기 때문에 페이지 테이블을 작성할 때 이를 구분해줄 도구가 필요한데 그것이 바로 `valid 비트 필드` 를 페이지 테이블을 추가해서 구분한다.

만약, backing store 에 있는, 즉 현재 메모리에 올라와있지 않은 것인지 아닌지를 구분할때 `valid 비트 필드` 를 통해 알 수 있다.  `valid 비트 필드` 를 통해 해당 페이지의 부재를 확인하고 메모리에 적재한 후에는 `valid 비트 필드` 를 메모리에 적재되어있다고 바꾸어 주면 되고 이러한 현상을 `페이지 결함` `페이지 부재`라고 한다.

요구 페이징의 기법에는 두가지 종류가 있는데 첫번째는 모든 페이지를 적재시키지 않고 CPU가 요구할때 `valid`를 바꾸어 페이지를 적재하는 방법이며, 두번째는 우선 필요할 것 같은 페이지를 적재시키고 필요할 때 다른 페이지를 적재시키는 방법이다. 

첫번째는 ` pure demand paging` 두번째는 `prepaging`기법이다.  첫번째의 경우 메모리 낭비를 줄일 수 있지만 요구에 의해 앞선 페이지 부재의 현상을 처리하는데에 있어서 부담이 발생할 수 있다 두번째의 경우 처리속도는 빠르지만 메모리가 낭비 될 수 있다.



## 페이지 교체 알고리즘



1. 디스크에서 필요한 페이지를 위치를 알아낸다
2. 빈 페이지 프레임을 찾는다
3. 새롭게 비워진 프레임에 새 페이지를 읽어오고 프레임 테이블을 수정한다
4. 사용자 프로세스를 재시작한다.

### FIFO 페이지 교체

메모리에 올라온 기간이 가장 오래된 페이지를 내쫒는다.

단점 : Belady 의 모순이 발생한다. 프로세스에게 프레임을 더 주었는데도 페이지 부재율이 더 증가하는 현상.

### 최적 페이지 교체  

모든 알고리즘보다 낮은 페이지 부재율을 보이며 Belady 의 모순이 발생하지 않는다.

단점 : 프로세스가 앞으로 메모리를 어떻게 참조할 것인지를 미리 알아야하기 때문에 구현이 어렵다.

### LRU 페이지 교체

최근의 과거를 가까운 미래의 근사치르 본다면 가장 오랜 기간 동안 사용되지 않은 페이지를 교체한다. Belady의 모순 형상을 야기하지 않으며 가장 오랫동안  사용하지 않은 페이지를 교체하며 가장 가까운 미래의 근사값으로 가장 최근의 과거를 사용한다.최적 알고리즘과의 대칭성 떄문에 성능이 유사하다.

구현방법은 두가지로 각 페이지 항목마다 사용시간 필드를 넣고  CPU에 논리적인 시계나 계수기를 추가하여 페이지에 대한 참조가 일어날 때 마다 페이지의 사용시간 필드에 시간 레지스터의 내용이 복사되는 방법과 페이지 번호의 스택을 유지하는 방법이 있다. 

#### LRU 근사 페이지 교체 

참조 비트를 이용한 알고리즘으로 각 페이지에 대한 N Bit를 참조용으로 유지하는 것이다.

#### LFU 

사용빈도가 가장 적은 페이지를 교체하는 방법. 활발하게 사용되는 페이지는 교체죄디 않는다. 프로그램 실행 초기에 많이 사용된 페이지가 그 후로 사용되지 않을 경우에도 프레임을 계속 차지하는 경우가 있을 수 있다.

#### 2차 기회 알고리즘

참조비트가 0이면 페이지를 교체하고 1이면 다시 한번 기회를 주고 다음 FIFO 페이지를 선택하기 위해 이동하는 알고리즘 

*추가

belady의 모순 : 일반적으로 생각해보면 페이지 `page frame`이 많아질 수록 가지고 있는 `page`의 개수가 많기 때문에 사용하려는 페이지가 없는 `page fault`문제가 덜 발생할 것이라고 예측하지만(일반적인 통념) Belady 의 모순은 해당 통념을 깨는 문제를 말한다.




# 가상 메모리



## 정의

> *물리 메모리 크키긔 한계를 극복하기 위해 나온 기술이다. 즉 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다.*



## 개요

메인메모리의 크기는 한정되어 있기 때문에 물리적인 메모리 크기보다 크기가 큰 프로세스는 실행시킬 수 없다.그렇다면 메인 메모리보다 크기가 큰 프로세스를 실행시키고 싶으면 어떻게 해야 할까? 메인메모리가 더 큰 컴퓨터를 사용해야하는가? 이러한 고민에서 나온 해결방법이 가상메모리이다.

프로세스의 모든 코드는 항상 필요한것이 아니다.오류처리,필요없는 배열의 부분은 프로세스가 잘 동작하면 필요없는 부분이 된다.이러한 점을 이용하여 필요한 부분만 메모리에 올림으로서 메모리에 올라가는 프로세스의 크기를 줄인다.

일단, 우리는 우리가 실행시키고자 하는 프로세스들을 페이징 한 후 페이지 단위로 프로세스를 자르면 페이지들마다 필요한 부분과 필요없는 부분으로 나눌 수 있다. 여기서 필요한 페이지만 메모리에 적재를 하면 낭비없이 우리가 필요한 모든 프로세스들을 메인 메모리에서 실행 시킬 수 있게 된다.

여기에서 핵심은 **필요한 부분만 메모리에 적재한다** 이다 . 프로세스를 실행할 때 실행에 필요한 부분만 메모리에 올리는데 이러한 일부분은 페이지 단위일 수도 있고 세그먼트 단위일 수도 있다.(대부분은 페이지 단위이다) 이처럼 현재 필요한 페이지만 메모리에 올리는 것을 `요구 페이징` 이라고 한다.



## Demanding Paging

`요구 페이징` 은 프로세스의 이미지를 페이지를 임시로 보관하는 공간인 backing store에 프로세스의 이미지를 저장한다.프로세스는 페이지의 조합이기 때문에 필요한 페이지만 메모리에 올린다.요구되는 페이지만 메모리에 올린다는 의미로 요구페이징이라고 부른다.

페이징 기법을 사용할 때 페이지 테이블이라는 부분을 놔두는데 MMU의 재배치 레지스터를 통해 논리주소를 물리주소로 바꾸어주는 주소 변환 과정을 거쳐  CPU가 프로세스는 연속적으로 할당되어 있다고 속게 만드는 작업을 한다. 더불어 요구 페이징 기법을 사용하면 페이지 중 메모리에 올라와있는 것도 있고 backing store에 보관되어 있는것도 존재한다. 이렇게 섞여 있기 때문에 페이지 테이블을 작성할 때 이를 구분해줄 도구가 필요한데 그것이 바로 `valid 비트 필드` 를 페이지 테이블을 추가해서 구분한다.

만약, backing store 에 있는, 즉 현재 메모리에 올라와있지 않은 것인지 아닌지를 구분할때 `valid 비트 필드` 를 통해 알 수 있다.  `valid 비트 필드` 를 통해 해당 페이지의 부재를 확인하고 메모리에 적재한 후에는 `valid 비트 필드` 를 메모리에 적재되어있다고 바꾸어 주면 되고 이러한 현상을 `페이지 결함` `페이지 부재`라고 한다.

요구 페이징의 기법에는 두가지 종류가 있는데 첫번째는 모든 페이지를 적재시키지 않고 CPU가 요구할때 `valid`를 바꾸어 페이지를 적재하는 방법이며, 두번째는 우선 필요할 것 같은 페이지를 적재시키고 필요할 때 다른 페이지를 적재시키는 방법이다. 

첫번째는 ` pure demand paging` 두번째는 `prepaging`기법이다.  첫번째의 경우 메모리 낭비를 줄일 수 있지만 요구에 의해 앞선 페이지 부재의 현상을 처리하는데에 있어서 부담이 발생할 수 있다 두번째의 경우 처리속도는 빠르지만 메모리가 낭비 될 수 있다.
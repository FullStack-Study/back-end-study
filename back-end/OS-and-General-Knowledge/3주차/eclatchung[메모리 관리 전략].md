# # 메모리 관리 전략
**메모리관리**는 프로세스들을 위해 메모리는 할당하고 제거하며 보호하는 활동 


### 논리 vs 물리 공간
- CPU가 생성하는 주소 ⇒ 논리 주소
- 논리 주소 공간 : 프로그램에 의해 생성된 모든 논리 주소 집합
- 메모리가 취급하는 주소 ⇒ 물리 주소
- 물리 주소 공간 : 논리 주소에 상응하는 모든 물리 주소 집합

- `매핑(Mapping)`
	- 프로그램 실행을 통해 가상 주소에서 물리주소로 바뀌는 작업
	- 메모리 관리 (Memory Management Unit/ MMU)에서 실행함
		- MMU : CPU에 탑재되어 가상주소를 실제 메모리 주소로 변환해주는 장치

##  메모리 관리 전략
- 메모리 용량 커짐에 따라 프로그램의 크기도 커짐 ⇒ 메모리 언제나 부족하게됨
- 제한된 메모리로 효율적 사용과 메모리 참조 방식을 제공하기 위한 전략

### 메모리 관리 요구 조건
1. 재배치 (relocation)
	- 프로그램은 디스크에 있다가 메인 메모리에 올라가서 프로세스가 되는 데, 그때 다시 **재배치**를 통해 메모리 관리를 수행해야함. ( swap in/out)
2. 보호 (protection)
	- 다른 프로세스에 속한 프로그램들은 허가 없이 읽기나 쓰기를 위해 임의의 프로세스 메모리를 참조하면 안됨
	- 메모리 보호는 운영체제가 아니라 처리기에 의해 이루어져야함. ⇒ 운영체제는 프로그램이 만들어 내는 메모리 참조를 예측할 수가 없기에.
4. 공유(sharing)
	- 필수적인 보호 기능을 침해하지 않는 범위에서 제한된 접근을 통해 메모리의 일부분을 공유할 수 있도록 허용해야함.
	- 메모리 관리자가 메모리 할당 이후에 계속해서 프로세스의 정보를 알고, 그 토대로 프로세스를 관리 해야함. 
	- (ex) 런타임 라이브러리
5. 논리적 구성(logical organization)
	- 주기억 장치 ⇒ 1차원의 주소공간
	- 대부분의 프로그램은 모듈이라는 단위로 구성
	- 논리적인 단위 : 세그먼트 ⇒ 모듈 처리 / 기능 별로 메모리에 따로 저장
6. 물리적 구성 (physical organization)
	- 적재(보조 기억장치에서 메인 메모리로 올리는 것)는 메모리관리에서 수행
	- 단, 오버레이는 프로그래머가 직접 설정해 주어야함.
		- 오버레이 : 주기억장치의 하나의 파티션에 저장할 수 있는 메모리 용량보다 더 큰 프로그램을 메모리에 올리게 될때 한번에 로드할 수 없음으로 프로그램을 몇개의 모듈로 구성하여 컴파일하고 필요한 모듈을 메모리로 올리는 기법

## 효과적인 메모리 사용
 메모리 낭비 방지
1. `동적 적재 (Dynamic Loading)`
	- 프로그램 실행에 반드시 필요한 루틴과 데이터만 적재하는 기법
	- 모든 루틴과 데이터는 항상 사용하지 않고, 실행시 필요하다면 그때 해당 부분을 메모리에 적재
	- 메모리 공간의 이용율을 높이기 위해 동적 적재를 해야한다. 
2. `동적 연결 (Dynamic Linking)`
	- 라이브러리 루틴 연결을 컴파일 시점에 하는 것이 아닌 실행 시점까지 미루는 기법
3. `스와핑(Swapping)`
	- 프로세스가 실행도기 위해서는 메모리에 있어야 하지만, 프로세스는 실행 중에 임시로 예비저장장치에 내보내여 졌다가 실행을 계속하기 위해 다시 메모리로 돌아올수 있다.
	- 예비저장장치는 대부분 속도가 빠른 디스크 사용
	- 문맥 교환으로 인한오버헤드가 발생할 수 있고 속도가 느려지지만, 메모리 공간 확보에는 효율적
	- 현재 운영체제에서는 변형해서 사용
	- 스와핑을 하기 위해서는 메모리의 프로세스가 완전히 휴지 (idle)임을 확인해야함.
	- 스와핑 순서
		1. 시스템은 실행 준비가 끝난 프로세스들을 준비완료 큐에 대기
		2. CPU스케쥴러는 다음 프로세스를 고를때 디스패처를 호출
		3. 디스패처는 이 큐에 있는 다음 프로세스가 메모리에 적재되어있는지 확인하고, 만약 올라와 있지 않다면 디스크에서 불러 들여야 한다.
		4. 만약 프로세스를 불어들이기 위한 공간이 메모리에 부족하다면 현재 메모리에 적재된 프로세스들을 내보내고 (swap out) 원하는 프로셋를 불러들인다. (swap in) 
		5. 그후 CPU의 모든 레지스터를 실행해야할 프로세스의 것으로 다시 적재 후 제어를 프로세스에게 넘긴다.

## 메모리 관리 전략
### `연속 메모리 할당`
1. `고정 분할 기법`
	- 시스템 생성시 주기억장치가 고정된 파티션들로 분할됨
	- 프로세스는 같은 크기의 파티션 또는 그 보다 큰 파티션으로 적재
	-  `내부 단편화`
2. `동적 분할 기법`
	- 파티션들이 동적으로 생성되며, 각 프로세스는 자신의 크기와 일치하는 크기의 파티션에 적재.
	- 할당과 제거를 반복하다보면 Scattered Holes가 생겨남 ⇒ `외부 단편`화가 발생
	- 연속 메모리 할당에서 외부 단편화를 줄이기 위한 할당 방식 ⇒ 처리 효율이 나빠짐.
		1. `최초 적합` ⇒ 성능 우승 ( 3가지 적합 중에서) 
			- 가장 처음 만나는 빈 메모리 공간에 프로세스를 할당
			- 빠름
		2. `최적 적합`
			- 빈메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스를 할당 
		3. `최악 적합`
			- 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당
			- 이렇게 생긴 빈 메모리 공간에 또다른 프로세스를 할당 할 수 있을 거라는 가정에 기인
3. `버디 시스템`
	- 큰 버퍼들을 반복적으로 이등분하여 작은 버퍼들을 만들며, 가능할 때마다 인접한 빈 버퍼들을 합치는 과정을 반복
	- L <= K <= U
		- 버디 시스템에서 사용할 수 있는 메모리 블록 (K) 
		- 할당 가능한 가장 작은 블록(L)
		- 가장 큰 블록의 전체 메모리 (U)
### `불연속 메모리 관리`
프로그램 일부가 서로 다른 주소 공간에 할당 될 수 있는 기법
1. `페이징` ( 가상메모리 사용 )
	- 메모리 공간이 연속적으로 할당 되어야 한다는 제약조건을 없애는 메모리 관리 전략
	- 논리 메모리는 고정크기의 페이지, 물리메모리는 고정크기의 프레임 블록으로 나누어 관리
		- 논리 주소 공간을 동일한 크기로 나눈것을 페이지(page)
		- 물리 메모리 공간을 나눈것을 프레임(frame)
	- 프로세스가 사용하는 공간을 논리 메모리에서 여러개의 페이지로 나누어 관리 하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장
	- MMU의 재배치 레지스터 방식을 활용해 CPU가 마치 프로세스가 연속된 메모리에 할당 된 것처럼 인식하도록 함
	- 내부 단편화 발생
2. `세그멘테이션` ( 가상 메모리 사용)
	- 페이징 기법과 반대로 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위인 세그먼트로 분할
	- 외부 단편화 발생
3. `세그멘테이션, 페이징 혼용 기법`
	- 페이징과 세그멘테이션도 각각 내부 단편화와 외부 단편화가 발생
	- 페이징과 세그멘테이션을 혼용해 이러한 단편화를 최대한 줄이는 전략
	- 프로세스를 세그먼트 (논리적 기능단위)로 나눈 다음 세그먼트를 다시 페이지 단위로 나누어 관리
	- 매핑 테이블을 두번 거쳐야하므로 속도가 느려짐
4. `메모리풀` 
	- 필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당 받아 놓고 필요할 때마다 사용하고 반납하는 기법
	- 메모리 풀없이 동적 할당과 해제를 반복하면 메모리의 랜덤한 위치에 할당과 해제가 반복되면서 단편화를 일으킬 수 있음 
	- 미리 공간을 할당해 놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않음
	- 필요한 크기 만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않음
	- 메모리 할당, 해제가 잦은 경우 메모리 풀을 쓰면 효과적이다. 
	- 메모리 단편화로 인한 메모리 낭비량 보다 메모리 풀을 만들었지만 쓰지 않을 때 메모리 양이 커질 경우 사용하지 말아야함.
	- 메모리 누수가 있음 ⇒ 할당해 놓고 사용하지 않는 순간에 도 할당되어있어서.

## 단편화 (Fragmentation)
메모리 공간이 충분함에도 불구하고 프로세스가 메모리에 적재되지 못해 메모리가 낭비되는 현상
- `외부 단편화`
	- 가변 불하 방식에서 메모리에 프로세스가 적재되고 제거되는 일이 반복되면서, 여유 공간이 충분함에도 불구하고 이러한 여유공간들이 조각으로 흩어져 있어 (Scattered Holes) 메모리에 프로세스를 적재하지 못해 메모리가 낭비되는 현상
- `내부 단편화`
	- 고정 분할 방식에서 프로세스가 실제 사용해야할 메모리보다 더 큰 메모리를 할당받아 메모리가 낭비되는 현상
		- 10k 블록에 7K 공간 사용시 3k 가 남음 ⇒ 내부 단편화 
- `압축`
	- 외부 단편화를 해소하기 위한 방법으로 Scattered holes를 모으는 방법
	- Scattered Holes를 합치는 과정에서 메모리에 적재된 프로세스를 정지시키고 한쪽으로 이동시키는 작업이 필요해 비효율적
	- 또한, Scattered Holes를 어느 자유공간을 기준으로 모을지 결정하는 알고리즘도 모호
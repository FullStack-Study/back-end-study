# 운영체제 정리

## 프로세스 동기화 
여러개의 스레드 또는 여러개의 프로세스가 병렬적으로 실행되는 상황에서 동일한 자원을 동시에 접근한다면, 한 프로세스가 공유 data에 접근 중일 때 다른 프로세스가 data를 변경한다면 데이터 일관성을 해칠 수 있다. 

### 문제 발생 해결 방법
1. 커널 동기화
	1. Mutex
	2. 세마포어 (Semaphore)
2. 유저 동기화
	1. Critical Section 임계영역


### 임계 영역
- 멀티 프로세스 환경에서 둘 이상의 프로세스가 동시에 접근해서는 안되는 공유 자원의 코드 영역
- 시간이 지나면 종료, 임계영역에 접근하기 위해서 지정된 시간만큼 대기 
- 프로세스간에 공유 자원을 접근하는데 있어서 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장 해줘야하는 영역
- 하나의 스레드가 임계 구역에 접근시
	- 요청 -> 필요시 대기 -> 임계구역 처리 -> 빠져나가

#### 임계 영역의 문제점
- 공유 데이터를 여러 프로세서가 동시에 접근하면 시간차로 예상치 못한 결과를 만들 수 도 있다. ⇒ 경쟁 상태 일어날 수 있음
- 임계영역 내에서는 작업을 빠르게 수행해야하며, 프로세스 하나가 임계영역 내에 오랫동안 머물면안됨.

### `경쟁상태` 
-  여러 프로세스가 공유 데이터를 동시에 저비근할 때 공유데이터에 대한 실행 순서에 따라 실행 결과가 달라지는 상황
- 경쟁 상태는 상호배제를 안했을 때 나타나는 현상

#### 임계구역에서 발생하는 문제를 해결하기 위한 3가지 조건 
1. `상호배제`
	- 하나위 프로세스가 임계영역에 들어가 있으면 다른 프로세스는 들어갈 수 없음. 
2. `진행` :
	- 임계 영역에 들어간 프로세스가 없다면, 어느 프로세스가 들어갈 것인지 적절히 선택해줘야함
3. `한정 대기` 
	- 기아 상태를 방지하기 위해 , 한번 들어갔다 나온 프로세스는 다음에 들어갈때 제한을 둠

### 락  ( lock )
- 하나의 스레드/ 프로세스가 자원을 사용하고 있는 동안 잠궈서 접근 못하게 하는 방식
- 변수값을 통한 무한 루프문을 통해서 구현
- 해제하는 부분에서 무한 루프 빠져나오지 못하면 ⇒ 의미 없는 코드 반복 수행하며 기다림 ⇒ busy-waits

##### 해결 방법
1. 알고리즘(피터슨 알고리즘) ⇒ 느림
2. 더이상 쪼개지지 않는 하드웨어 명령어로 구현하는 방법
3. 인터럽트를 disable하고 enable하는 방법

### 뮤텍스
- 0과 1을 가진 이진 세마포어와 유사
- 다른 프로세스간 동기화시 사용
- 임계 영역을 가지는 스레드들의 실행 기간을 서로 겹치지 않게 하기 위해서 프로세스나 스레드를 단독으로 실행
- 락을 획득한 스레드는 그 락을 해제 해야하

### 세마포어
- 공유 자원에 대한 접근을 제한하는 방법 중 하나 P, V연산이 있음
	- P : 검사를 나타내고 임계여역에 들어가기 전에 수행 `wait`
		- 세마 포어의 값을 검사하여 1을 감소시키며, 프로세스를 대기 시키는 wait동작
	- V : 증가를 나타내고 임계여역에서 나올 때 수행 `signal`
		- 세마포어의 값을 1 증가시키는 연산으로 대기중인 프로세스를 깨우는 신호를 보내는 signal 동작 
- 한 프로세스에서 세마포어 값을 변경하는 동안 다른 프로세스가 동시에 이 값을 변경하면 안됨. 
- 임계영역 코드에 진입하기전 P(mutex) 연산을 하고 나올때 V(mutex) 연산을 하는 것을 알 수 있음. 



### `불연속 메모리 관리`
프로그램 일부가 서로 다른 주소 공간에 할당 될 수 있는 기법
1. `페이징`
	- 고정 분할
	- 페이지 테이블이라는 자료 구조 형태로 관리된다.
	- page table : 프로세스의 페이지 정보 저장, 하나의 프로세스는 하나의 페이지 테이블을 가진다.
		- index : 프레임의 시작 주소
2. `세그멘테이션`
	- 가변 분할 
	- 가상 메모리를 서로 크기가 다른 논리적 단위이 ㄴ세그먼트로 분할하고 메모리를 할당하는 기법
	- 세그먼트 테이블을 참조하여 해당 세그먼트의 시작주소와 더해져서 실제적임 물리적 위치로 변환 

## 가상메모리 
- 프로세스 전체가 메모리내에 올라오지 않더라도 실행이 가능하도록 하는 기법 
- 프로그래머는 메모리 공간으로 구성된 엄청난게  큰 배열로 추상화 시켜줌. 
- 가상 메모리는 파일의 공유를 쉽게 해주고 공유 메모리 구현을 가능하게 해줌
- 프로세스 생성을 효율적으로 처리할 수 있는 매커니즘을 제공함. 


### 가상 메모리의 장점
- 물리 메모리보다 사용자 프로그램이 커져도 됨.
- 많은 프로그램을 동시에 수행할 수 있음
- 입출력 횟수가 줄어듬

### 가상 메모리 역할
- 논리 메모리를 물리 메모리로부터 분리시켜주는것

### 가상 메모리 구현
- 요구 페이징
- 요구 세그먼테이션 

## 요구 페이징 ( Demand Paging)
- 초기에 필요한 것들만 적재
- 실행 과정에서 실제로 필요할 때 적재

### 장점
- 실제 필요한 페이지들만 메모리로 읽어오므로 사용되지 않는 페이지를 메모리로 가져오지 않음으로 시간낭비와 메모리 공간 낭비 줄일 수 있음
- 프로세스가 메모리에 존재하는 페이지들만 접근하는 한 실행은 정상적으로 진행

### 단점 
프로세스가 메모리에 올라와 있지 않는 페이지를 접근시 ⇒ 페이지 부재 트랩(page -fault trap)을 발생

### 종류
- `pure demand paging`
	- 진짜 필요한 애들만 가져오는 것 
	- page fault일어남
	- 속도는 느리지만 메모리 절약
- `prepaging`
	- 지금 필요하지 않아도 미리 몇페이지 가저옴
	- 속도는 빠름
	- page fault가 적음
	- 메모리 낭비가 있음 

> `swapping`과 `demand paging`의 차이점  
> `swapping` : 프로세스 단위로 움직임  
> `demand paging` : 	페이지 단위로 움직임  


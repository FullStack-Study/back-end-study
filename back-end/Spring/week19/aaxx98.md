# 2. 테스트

### 웹을 통한 DAO 테스트 방법의 문제점

    -   프로그램을 완성하고 나서야 테스트가 가능함
    -   어떤 코드에서 문제가 발생했는지 찾기가 힘들다.

### 작은 단위의 테스트

    -   테스트 하고자 하는 대상에만 집중하여 테스트함
    -   작은 단위(클래스)의 기능만을 테스트 한다.
    -   단위 테스트 후 통합 테스트를 진행하면 어떤 코드에서 문제가 발생했는지 찾기 수월함

### 자동 수행 테스트

    -   인간이 수동으로 테스트 결과를 판단하는 과정에서 실수 가능성이 있음
    -   반복행동을 자동화한다.
    -   번거롭지 않고 빠르게 실행 가능

## JUnit

-   Java의 단위 테스트를 위한 프레임워크

    -   일정한 패턴을 가진 테스트를 만들 수 있음
    -   많은 테스트를 간단히 실행 가능
    -   테스트 결과를 종합해서 볼 수 있음
    -   테스트가 실패한 곳을 빠르게 찾을 수 있음

-   테스트 메소드 조건

    -   `@Test` 어노테이션 추가
    -   `public`으로 선언

-   검증 코드 전환
    -   `assertThat` static 메소드 이용
        -   `assertThat(테스트 대상, matcher(예상결과))`
        -   ex) `assertThat(user2.getName(), is(user.getName()));`

### 테스트 결과의 일관성

-   테스트가 외부 상태에 따라 결과가 달라지는 문제
    -   data를 등록하는 테스트를 여러번 반복하면 기본 key 중복으로 인한 에러가 발생한다.
    -   User Table을 한번 삭제해야한다.(별도 작업 필요, 테스트가 번거로워짐)
    -   `deleteAll()`(users테이블 데이터 전체 삭제), `getCount()`(users테이블 전체 row 개수) 메소드 추가로 해결
-   ### 코드에 변경사항이 없다면 같은 테스트 코드는 늘 동일한 결과를 내야한다.

### 포괄적인 테스트

    -   성공하는 테스트만 골라서 만드는 실수를 하지 말아야함
    -   예외 상황과 같이 거의 모든 상황과 입력값을 고려하여 Test 해야함

## [테스트 주도 개발 (TDD : Test Driven Development)](https://wikidocs.net/224)

실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 작성하지 않는다.

    -   무엇을 테스트할 것인지 결정
    -   실패하는 테스트 작성
    -   테스트를 통과하도록 리팩토링, 테스트 코드 리팩토링
    -   반복

-   테스트 작성 시간과 애플리케이션 코드를 작성하는 시간 간격이 짧아야한다.
-   테스트 코드가 잘 정의된 기능정의서 역할을 한다.

### Unit이 하나의 테스트를 수행하는 방식

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. `@Before`가 붙은 메소드가 있으면 실행한다
4. `@Test`가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. `@After`가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

![image](https://user-images.githubusercontent.com/74856502/124325042-f83dc900-dbbe-11eb-85cc-81448cefa1f9.png)

-   각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다
    -   `@Test` 메소드가 2개 있다면 테스트 실행중 이 클래스의 오브젝트를 2번 만들고 버린다.
    -   각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 보장하기 위해 매번 새로운 오브젝트를 생성한다.

### Fixture

-   테스트를 수행하는 데 필요한 정보나 오브젝트
-   `@Before` 메소드 내에 생성해둔다.

## 테스트를 위한 애플리케이션 컨텍스트 관리

-   테스트 메소드 실행 시 스프링 어플리케이션 컨텍스트도 매번 생성된다. - 빈이 많아지고 의존관계가 복잡해지면 생성에 많은 시간이 걸림 - 어플리케이션 컨텍스트를 한번만 만들고 여러 테스트가 공유해서 사용하도록 하자.

```java
@RunWith(SpringlUnit4ClassRunner.class)
// 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장 기능 지정
@ContextConfiguration(locations="/applicationContext.xm1")
// 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
public class UserDaoTest {
    @Autowired // 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아 자동으로 DI 해줌
    private ApplicationContext context;
    ...
}
```

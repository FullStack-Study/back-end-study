# 2장 :: 테스트

## 테스트
- - - -
- 작은 단위로 쪼개서 집중 할 수 있어야함
- 한꺼번에 몰아서 하면 과정이 복잡해지고 정확한 원인을 찾기 힘듬
- 테스트 생성시 고려할 부분
	-  테스트 검증의 자동화
- 자동으로 수행되도록 코드로 만들어지는 것이 중요
	- 자주 반복해서 테스트를 가능하게 하기때문이다.

### 단위테스트 Unit Test
- 작은 단위의 코드에 대해 테스트 수행
#### 테스트 종류
- 단위 테스트
- 시스템 테스트  : 결함을 찾아내기 위해서 소프트웨어를 실행시켜서 테스트를 수행한느 작업
	- 테스트 조직에서 담당, 요구사항 기술서를 토대로 테스트 계획서를 작성해서 테스트 케이스 만듬
- 스모크 테스트 : 시스템의 안전성 및 주요기능이 제대로 작동하는지 확인. 버그를 찾는 것이 아니라 제품의 안정성을 우선으로 함
- 화이트 / 블랙 박스
	- 화이트 박스 테스트 : 모듈안의 작동을 관찰하여 소스코드에 있는 각각의 라인이 제대로 수행되는지를 철저하게 시험
	- 블랙 박스 테스트 : 소스코드 안을 들여다 보지 않고 모듈이 요구 사항에 맞게 기능이 잘 동작하는지 점검하는 테스트
- 포지티브/네거티브 테스트
	- 포지티브 테스트 : 정상적인 값을 입력했을때 정상적인 결과가 나오는지 테스트
	- 네거티브 테스트 : 정상적이지 않은 값을 입력할 때나 비정상적으로 시스템ㅇ르 조작할 때를 테스트 하는 것

## JUnit
- - - -
- 자바로 단위 테스트를 만들때 유용하게 사용가능
- 자바 테스팅 프레임워크
- **테스트 메소드를 실행할때마다 테스트 클래스의 오브젝트를 새로 만듬**
	- 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게함
- **테스트 메소드 요구 조건**
	- 메소드 `public`으로 선언
	- `@Test` 어노테이션을 메소드에 붙임


#### 검증 코드 전환
```JAVA
//. if..else 문장
if(!user.getName().equals(user2.getName())){ //...}

//JUnit 이용
assertThat(user2.getName(), is(user.getName()));
```
- `assertThat`이라는 스태틱 메소드를 이용하여 if문장을 변경할 수 있다.
	- 첫번째 파라미터 값을 뒤에 나오는 매처 matcher라고 불리는 조건으로 비교하여 일치하면 다음으로 넘어가고 아니면 테스트 실패하도록 만듬
	- `is()` : 매쳐의 일종 (equals()로 비교해주는 기능을 가짐)
	- 결과
		- 검증을 통해 기대한 결과가 아니면 `AssertionError`를 던짐
	- 예외
		- `@Test(expected=EmptyResultDataAccessException.class)`
			- `@Test`애노테이션의 expected 엘리먼트
				- 테스트 메소드 실행 중에 발생하리라 기대하는 예외 클래스를 넣음
				- 정상적으로 테스트 메소드 마치면 테스트 실패
				- expected에서 지정한 예외가 던져지면 테스트가 성공

#### 테스트 결과의 일관성
- 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전의 상태로 만들어주면 여러 번 반복해서 실행하더라도 항상 동일한 결과를 얻을 수 있음
- 단위 테스트는 항상 일관성 있는 결과가 보장되어야 함
	- DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 함
	- 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 해야함


### 테스트 주도 개발 TDD :: Test Driven Development
- 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성한느 방식
- 원칙 :  ** 실패하나 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다 **
- 장점
	- 코드를 만들어 테스트를 실행한느 그 사이의 간격이 매우 짧음

#### `@Before`
- Junit이 제공하는 애노테이션
- @Test 메소드가 실행되기 전에  먼저 실행돼야하는 메소드를 정의함
- 각 테스트 메소드에 반복적으로 나타났던 코드를 제고하고 해당 `@Before`어노테이션을 선언한 메소드로 옮김
- 테스트 메소드의 일부에서만 공통적으로 사용되는 코드가 있으면 @Before보다는 일반적인 메소드 추출 방법을 써서 메소드를 분리하고 테스트 메소드에서 직접 호출하여 사용하게 만드는 것을 추천
- 테스트 수행하는 방식
	1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾음
	2. 테스트 클래스의 오브젝트를 하나 만듬
	3. @Before가 붙은 메소드가 있으면 실행
	4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둠
	5. @After가 붙은 메소드가 있으면 실행
	6. 나머지 테스트 메소드에 대해 2~5번을 반복
	7. 모든 테스트의 결과를 종합해서 돌려줌
		- @Before나 @After 메소드를 테스트 메소드에서 직접 호출하지 않기 때문에 서로 주고 받을 정보나 오브젝트가 있으면 인스턴스 변수를 이용해야함
	
#### 픽스처 `fixture`
- 테스트를 수행하는데 필요한 정보나 오브젝트

### 스프링 테스트 적용
- - - -
- JUnit이 배번 테스트 클래스의 오브젝트를 새로 만들어서 애플리케이션 컨텍스트가 생길 수 있음
- 애플리케이션 컨텍스트 관리를 해야함
![652EBE92-5700-4D9A-B72A-CE4B9308F9A2](https://user-images.githubusercontent.com/46446434/124301928-76887400-db9b-11eb-9ace-cd18a998b485.png)
- `@RunWith()` : JUnit 프레임워크의 테스트 실행 방법을 확장시에 사용함
	- SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해줌
- `@ContextConfiguration` : 자동으로 만들어줄 애플리케이션 컨텍스트의 설정 파일 위치를 지정
- `@Autowired` : 스프링 DI에 사용되는 특별한 애노테이션
	- 해당 어노테이션이 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수타입과 일치하는 컨텍스트 내의 빈을 찾음 -> 타입일치하는 빈이 있으면 인스턴스 변수에 주입
	- 메소드가 없어도 주입 가능
	- 별도의 DI설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있음
	- 타입에 의한 자동 와이어링
#### 테스트에 DI를 이용하는 방법
- 테스트 코드에 의한 DI
	- 예외적인 의존관계를 강제로 구성해서 테스트 할 경우
- 테스트를 위한 별도의 DI 설정
	- 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트 테스트 시
- 컨테이너 없는 DI 테스트
	- 우선적으로 고려
	- 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결

### 학습테스트 learning Test
- 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에서도 테스트 작성하는 것
- 장점
	- 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있음
	- 학습 테스트 코드를 개발중에 참고 할 수 있음
	- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와줌
	- 테스트 작성에 대한 좋은 훈련이 됨
	- 새로운 기술ㅇ르 공부하는 과정이 즐거워짐

### 버그 테스트
- 코드에 오류가 있을 때 그 오류를 가장 잘드러내줄 수 있는 테스트
- 실패하도록 만들어야함 / 버그가 원인이되서 테스트가 실패하는 코드 -> 버그 테스트가 성공할 수 이도록 애플리케이션 코드를 수정
- 장점
	- 테스트의 완성도를 높여줌
	- 버그의 내용을 명확하게 분석하게 해줌
	- 기술적인 문제를 해결하는데 도움이 됨

![image](https://user-images.githubusercontent.com/46446434/124301592-01b53a00-db9b-11eb-9c20-001fd1c889dd.png)
# 들어가며 & 1장

## 스프링이란 무엇인가?
### 스프링
- 자바 엔터프라이즈 애플리케이션 개바렝 사용되는 애플리케이션 프레임워크 
- 애플리케이션의 바탕이 되는 ㄴ틀 , 곧통 프로그래밍 모델, 기술 API를 제공
#### 스프링 런타임 엔진
- ( aka 스프링 컨테이너, 애플리케이션 컨텍스트)
- 설정 정보를 참고하여 애플리케이션을 구성하는 오브젝트를 생성하고 관리함
- 독립적으로 사용가능
- 보통 웹모듈에서 동작하는 서비스나 서블릿으로 등록해서 사용
#### 프로그래밍 모델
- 애플리케이션을 구성하는 오브젝트가 생성되고 동작하는 방식에 대한 틀
#### 공통 프로그래밍 모델
	1. IoC/ DI
		- 오브젝트의 생명주기와 의존관계에 대한 프ㅗ그래밍 모델
		- 객체 지향 설계 원칙과 디자인 패턴의 핵심원리를 담고 있음
		- 프레임워크의 근간
	2. 서비스 추상화
		- 스프링 -> 이식성이 뛰어나고 유연한 애플리케이션을 만들 수 있음 ( 서비스 추상화로 인한 효과)
		- 구체적인 기술과 환경에 종속되지 않도록 유연한 추상계층을둠
	3. AoP
		- 애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화 하는 프로그래밍 모델
#### 프레임워크
- 프로그래밍 모델 제공 
- 애플리 케이션 코드가 어떻게 작성되야 하는지에 대한 기준 제시
	`vs 라이브러리`
	- 라이브러리 : 애플리케이션 흐름을 (개발자가) 직접 제어
	- 프레임워크 : 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용 
#### 기술 API
- UI작성, 웹프레젠테이션 계층 등에서 필요한 주요기술을 일관된 방식으로 사용할 수 있도록 지원, 전략 클래스등을 제공

## 제 1 장 오브젝트와 의존관계
스프링이 자바에서 가장 중요하게 가치 두는 것. == 객체 지향 프로그래밍
#### 객체 지향 설계의 기초와 원칙
1. 디자인 패턴 : 재활용 가능한 설계 방법
2. 리팩토링
3. 단위 테스트

### DAO
#### `DAO` : Data Access Object 
- DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트 
- 사용자 정보를 저장시에는 자바빈 규약을 따르는 오브젝트를 이용하면 편하다
	- `Java Bean` 
		- 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다.
		- 현재는 아래 두개의 관례에 따라 만들어진 오브젝트를 뜻함
			- 디폴트 생성자
				- 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다.
			- 프로퍼티
				- 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고함
				- getter/setter를 이용하여 조회/수정
#### `JDBC`를 이요하는 작업의 일반적인 순서
- `JDBC(Java Database Connectivity)` : 자바에서 DB프로그래밍을 하기 위해 사용되는 API
1. DB 연결을 위한 커넥션 가져오기
2. SQL을 다음 Statement(or PreparedStatement)를 만듬
3. 만들어진 Statement실행
4. 조회의 경우 SQL쿼리의 실행결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨줌
5. 작업 중에 생성된 커넥션, Statement, ResultSet같은 리소스는 작업을 마친 후 반드시 닫아줌
6. JDVC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언하여 예외가 발생하면 메소드 밖으로 던지게 함
##### `classpath` 
- 빌드시 컴파일된 class 파일들의 위치 경로
- /가 없어도 항상 루트에서 시작함
 
### 관심사의 분리 (Speration of Concerns)
- 관심이 같은 거 끼른느 하나의 객체 안으로 또는 친한 객체로 모이게 하고 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것
 
### 리팩토링 (refactoring)
- 기능에 영향을 주지 않으면서 코드 구조만 변경하여 코드가 깔끔해지고, 미래의 변화에 좀 더 손쉽게 대응 할수 있는 코드가 됨
- 메소드 추출( `extract method` )
	- 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것
- 템플릿 메소드 패턴 (`template mehtod pattern`)
	- 상속을 통한 확장
	- 슈퍼클래스에서 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상메소드나 오버라이딩이 가능한 `protected`메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법
	- 변하지 않는 기능 -> 수퍼 클래스
	- 자쥬 변경되며 확장할 기능 -> 서브 클래스
	- `hook method` : 슈퍼 클래스에서 디폴트 기능을 정의해두거나 비웠다가 서브 클래스에서 선택적으로 오버라이드할 수 있도록 만들어준 메소드
	- 추상 메소드 : 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨줌
- 팩토리 메소드 패턴(`factory method pattern`)
	- 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

> 추상화 : 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업  
> 	- 자바의 추상화 도구 : `인터페이스`  
> 	- 인터페이스 : 자신을 구현한 클래스에 대한 구체적인 정보를 모두 감춤  
> 	- 어떠한 일을 하겠다는 기능만 정의  
####  `인터페이스`
```java

public interface Animal {
	void live();

	void death();
}

public class Human implements Animal{
	public void live() {
	////
}
	public void death(){
	////
	}
	// 인터페이스에 명시되어있는 추상메소드를 모두 구현해야한다. 
}

```

### 디자인 패턴
- - - -
- 소프트웨어 설계시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔류션
- 확장성 추구 방법
	- 클래스 상속 (is-a)
	- 오브젝트 합성 (has-a) 
		- Police Has a Gun 
``` JAVA
class Gun :
...
class Police(Gun):
...
```

### 오브젝트
- `서비스` : 사용되는 오브젝트
- `클라이언트` : 사용하는 오브젝트
- 오브젝트 사이의 관계는 런타임시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어짐
- 오브젝트 만드는 방법
	1. 직접 생성자 호출
	2. 외부에서 만들어 준 것을 가져오는 방법
		- 외부에서 만든 오브젝트를 전달받을려면 메소드 파라미터나 생성자파라미터를 이용하면됨
- 클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기에 만들어지는 것 ≠ 오브젝트 
- 코드에서 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용시, 그 클래스가 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있음 ( 객체지향의 `다형성` 덕분) 
- 오브젝트의 동일성(`Identity`)과 동등성(`Equality`)
	- 동일성 : 완전히 같은 오브젝트인가  : 동일성 비교 == 
	- 동등성 :동일한(equivalent) 정보를 가진 오브젝트인가 : equals() 메소드 

### 객체 지향 설계 원칙 (`SOLID`)
- `SRP (the single responsibility principle)` : 단일 책임 원칙
- `OCP (the open closed principle)` : 개방 폐쇄 원칙
- `LSP (the Liskov Substituction principle)` : 리스코프 치환 원칙
- `ISP (the interface segregation principle)` : 인터페이스 분리 원칙
- `DIP ( the dependency inversion principle)`  : 의존관계 역전 원칙
#### 개방 폐쇄 원칙
- 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 함
- 높은 응집도와 낮은 결합도
##### 응집도 coherence
	- 높은 응집도 : 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있음
##### 결합도 coupling
	- 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도 
	- 낮은 결합도 :  책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것이 바람직함
	- 변화 대응 속도 빨라짐
	- 구성깔끔
	- 확장 매우 편리

#### 전략 패턴 (`Strategy Pattern`)
[전략패턴](https://victorydntmd.tistory.com/292)
- 자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 앙ㄹ고리즘을 인터페이스를 통해 똥째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
- 컨텍스트를 사용하는 클라이언트는 컨텍스트가 사용할 전략을(context) 컨텍스트의 생성자 등을 통해 제공한느 것이 일반적

### 제어의 역전 `IoC (Inversion of Control)`
- - - -
#### factory
- 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는것
- 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임ㅇ르 깔끔하게 분리하는 목적
- 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할
![image](https://user-images.githubusercontent.com/46446434/124301622-0bd73880-db9b-11eb-915b-64a246d182fd.png)
![image](https://user-images.githubusercontent.com/46446434/124301716-26a9ad00-db9b-11eb-8a38-6c39928cf2f8.png)


#### 제어의 역전
- 프로그램의 제어 흐름 구조가 뒤바뀌는 것
- 제어의 흐름 개념을 꺼꾸로 뒤집는 것
- 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요 할 때 호출되어 사용하게 한다는 개념
- 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계 설정, 사용, 생명주기 등을 관장하는 존재가 필요 ⇒` ex) DaoFactory`

### 빈 (`bean`)
- 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
- 자바빈 / 엔터프라이즈 자바빈 (`EJB`)에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트를 말함
- IoC 오브젝트 == 빈팩토리
	- 빈팩토리 : 빈의 생성과 관계 설정 같은 제어 담당
	- 빈팩토리 == 애플리케이션 컨텍스트
		- 애플리케이션 컨텍스트 : IoC방식ㅇ르 따라 만들어진 일종의 빈팩토리
		- 애플리케이션 전반에 거쳐 모든 구성요소의 제어 담당하는 IoC 엔진
- 스프링 빈 
	- 스프링 컨테이너가 생성과 관계 설정, 사용등을 제어해주는 제어의 역전이 적용된 오브젝트
	- Spring IoC컨테이너에 등록되어 관리되고 있는 객체 
		- 등록 방법
			1. Component Scan을 통한 등록( Annotation )
			2. 빈설정 파일에 직접 등록
#### 등록
- `@Component` : 해당 어노테이션이 붙어있는 클래스, 인터페이스는 자동으로 IoC컨테이너에 등록 
- `@Configuration`: 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스로 인식할 수 있음
- `@Bean` : 오브젝트 만들어주는 메소드
![image](https://user-images.githubusercontent.com/46446434/124301732-2b6e6100-db9b-11eb-9d51-b219c1dc17a8.png)
- `@Configuration` 이 붙은 자바 코드를 설정정보로 사용하려면 `AnnotationConfigApplicationContext`를 이용하면됨
	- `getBean()`이라는 메소드를 통해 오브젝트를 가져올 수 있음
		- 기본적으로 Object타입 리턴
		- ApplicatioinContext가 관리하는 오브젝트를 요청한느 메소드
		- java5이상 부터 제네릭 메소드 방식을 이용하면 지저분한 캐스팅 코드 사용 안해도됨
#### 애플리케이션 컨텍스트
- 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계 설정을 담당함
- `Application Context`를 사용시 이점
1. 클라이언트는 구체적인 팩토리 클래스를 알 필요 없음
2. 애플리케이션 컨텍스트는 종합 IoC서비스를 제공해줌
3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법 제공
#### 애플리케이션 컨텍스트를 사용한 Factory와 아닌 Factory 비교
- DaoFactory에서 userDao()를 여러번 호출시 동일한 오브젝트가 들어오는가?
	- 동일한 오브젝트가 아님
	- 애플리케이션 컨텍스트 X
![Uploading image.png…]()
- 애플리케이션 컨텍스트를 사용한 Factory에서 getBean이용시 userDao가 동일한가?
	- 동일한 오브젝트임
	- 싱글톤이기 때문에 동일한 오브젝트가 나옴
	- 애플리케이션 컨텍스트 == IoC 컨테이너 == `싱글톤 레지스트리`
		- 싱글톤레지스트리 : 싱글톤을 저장하고 관리하는 곳.
		- 스프링은 기본적으로 별다른 설정없으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만듬
![Uploading image.png…]()

**싱글톤으로 빈을 만든 이유 ⇒ 클라이언트에서 요청올때마다 로직의 오브젝트를 새로 만들시에 서버 부하가 생김**

### 싱글톤 패턴
- 애플리케이션 안에 제한된 수, 대개 한개의 오브젝트만 만들어서 사용
- 구현 방법
	- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만듬
	- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의함
	- 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게함. 생성된 오브젝트는 스태틱 필드에 저장됨 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수 도 있음
	- 한번 오브젝트(싱글톤)가 만들어지고 난 후에는 `getInstace()`메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨줌
#### 싱글톤 레지스트리
- 스프링이 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는 것
- static 메소드와 private 생성자를 사용해야하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용가능 하게 해줌
- 스프링 ⇒ IoC 컨테이너 && 싱글톤 레지스트리
### 싱글톤
- 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근하여 사용할 수가 있음
- 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지않은 무상태 `stateless`방식으로 만들어져야함
- **스프링의 싱글톤 빈으로 사용되는 클래스를 만들때 개별적으로 바뀌는 정보를**
	- 로컬변수로 정의
	- 파라미터로 주고 받으면서 사용
	- 단, 
		- 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 됨
		- 읽기 전용 속성을 가졌다면 싱글톤에서 인스턴스 변수로 사용 가능
			- 하지만 `static final`이나 `final`을 더 추천함
#### 빈의 스코프
- 빈이 생성되고 존재하고 적용되는 범위
- 대부분의 빈은 싱글톤 스코프를 가짐
- 다른 스코프
	- 프로토타입 스코프 : 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만듬
	- 요청 스코프 : 새로운 HTTP 요청 생길때마다 생성
	- 세션 스코프 : 웹의 세션과 스코프가 유사

### DI 의존관계 주입 `Dependency Injection`
- - - -
- 오브젝트 레퍼런스를 외부로 부터 제공(주입) 받고 이를 통해 여타 오브젝트와 다이나믹하게 의존 관계 만들어지는 것이 핵심
- 구체적인 의존 오브젝트와 그것을 사용할 주체(보통 클라이언트)를 런타임 시에 연결해주는 작업
- 의존 오브젝트와의 관계 주입 방법
	- 생성자 사용
	- 수정자 메소드 사용 (`setter`)
	- 일반 메소드를 이용
- 세가지 조건을 충족해야함
	1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않음. 그러기 위해서는 인터페이스에만 의존해야함
	2. 런타임 시점의 의존관계는 컨테이너나 팩토리같은 제3의 존재가 결정
	3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어짐
	- 제 3의존재 : 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트
#### 의존관계
( UML )
![4CE07981-AA71-413A-8345-93C10BD47BF7](https://user-images.githubusercontent.com/46446434/124301760-35905f80-db9b-11eb-88a9-6836755ffed4.png)
A가 B에 의존
- 의존 : 의존대상 B가 변하면 A에게도 영향이감
- A가 B에 정의된 메소드 호출하여 사용
- 의존관계에는 방향성이 존재함
- A는 B에 의존해도 B는 A에 의존안할 수 있음
- **인터페이스를 통해 의존 관계를 제한해주면 그만큼 변경에 자유로워짐**⇒ 결합도가 낮다

![ECD5472B-D922-4B92-BC8D-5A09314C0884](https://user-images.githubusercontent.com/46446434/124301774-3aedaa00-db9b-11eb-92ab-1ef58448c13a.png)
- ** 런타임 의존관계 (aka 오브젝트의 의존관계)**
	- 런타임시에 오브젝트 사이에서 만들어지는 의존관계
		- 의존오브젝트(`dependent object`) : 프로그램이 시작되고 오브젝트가 만들어지고 나서 런타임시에 의존관계를 맺는 대상, 실제 사용 대상 
#### 의존관계 검색 `dependency lookup`
- 의존관계를 맺는 방법이 스스로 검색을 이용하는 것
- 코드에서 구체적인 클래스에 의존하지 않고, 런타임 시에 의존관계를 결정한다는 점은 의존관계 주입과 비슷
- 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
- `getBean()`메소드 사용
- 활용
	-  서버에서는 main()과 같은 기동 메소드는 없지만 사용자의 요청을 받을때마다 main()메소드와 비슷한 역할을 하는 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야함.
### XML
- - - -
- DI 의존관계 설정정보 만듬
- 단순 텍스트 파일
- 빌드 작업 없음
- 리턴 타입 지정하지 않아도됨
- 루트 엘리먼츠 `<beans>`
- `@Configuration` ⇒ `<beans>`
- `@Bean` ⇒ `<bean>`
- 수정메소드 ⇒ `<property>`
	- name : 프로퍼티 이름
	- ref : 수정자 메소드를 통해 주입해줄 오브젝트 빈이름

# 3. 템플릿

## 3.1 다시 보는 초난감 DAO

### 예외 상황

-   DB 커넥션을 사용하는 메소드에서 어떤 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 한다.
    -   `[Connection].close()`가 반드시 실행되어야 한다.
    -   메소드 실행 중, 예외가 발생하면 반환코드가 실행되지 않을 수 있다.

### 예외 처리

-   `try`: 예외가 발생할 가능성이 있는 코드를 `try` 블록으로 묶어준다.
-   `catch`: 예외가 발생했을 때 부가적인 작업을 한다.
-   `finally`: `try` 블록에서 예외가 발생해도 무조건 실행된다.

## 3.2 변하는 것과 변하지 않는 것

### try/catch/finally 코드의 문제점

-   `try/catch/finally` 블록의 2중 줕첩
-   DB 커넥션을 사용하는 모든 메소드 마다 예외 처리 코드가 반복됨

### 템플릿 메소드 패턴 적용

-   변하지 않는 부분은 슈퍼클래스에 작성
-   변하는 부분은 추상 메소드 오버라이딩을 통해 새롭게 정의하여 사용
-   문제점
    -   DAO 로직마다 상속을 통해 새로운 클래스를 만들어야함
    -   확장구조가 설계 시점에서 고정됨

### 전략 패턴의 적용

![image](https://user-images.githubusercontent.com/74856502/125138625-ef626f80-e149-11eb-841e-5e43107199bd.png)

-   클래스 레벨에서 인터페이스를 통해서만 의존하도록 하는 구조
-   변하지 않는 부분은 컨텍스트의 `contectMethod()`로 작성
-   변하는 부분은 전략이 됨
    -   구조를 인터페이스로 생성하고 클래스로 구체화
-   컨텍스트안에서 이미 전략을 결정하고 있음(DI 적용 필요)
    -   Factory 패턴 적용으로 전략을 선택하는 클라이언트 클래스 추가

## 3.3 JDBC 전략 패턴의 최적화

-   오브젝트를 한 번 생성하기 위해 매번 구현 클래스를 만들어 생성할 필요는 없다. 클래스 파일이 늘어난다.
-   특정 메소드 내부에서 한 번만 사용되는 오브젝트를 `로컬 클래스`로 정의한다.
-   오브젝트가 한 번만 생성된다면 클래스 선언과 오브젝트 생성을 동시에 해도 된다. `익명 내부 클래스`로 선언과 동시에 생성할 수 있다.

### 중첩 클래스

-   `static class`: 독립적인 오브젝트로 만들어질 수 있음
-   `inner class`: 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있음
    -   `member inner class`: 오브젝트 레벨에 정의됨
    -   `local class`: 메소드 레벨에 정의됨
    -   `anonymous inner class`: 익명 내부 클래스, 이름이 없는 클래스
